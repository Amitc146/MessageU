from client import Client
from client_service import ClientService
from client_dao_sqlite import ClientDAOSQLite
from message import Message
from message_service import MessageService
from message_dao_sqlite import MessageDAOSQLite
from uuid import *
from server_responses import *

PUBLIC_KEY_LENGTH = 160
USERNAME_LENGTH = 255
GET_SYMMETRIC_KEY = 1

client_service = ClientService(ClientDAOSQLite('server.db'))
message_service = MessageService(MessageDAOSQLite('server.db', client_service))


def fetch_header(conn):
    """
    Reading the header of the request sent by a client.
    :param conn: client connection
    :return: request header
    """

    data = conn.recv(22)
    if not data:
        raise ConnectionResetError
    t = struct.unpack('<16sBBI', data)
    header = {'client_id': t[0], 'version': t[1], 'code': t[2], 'payload_size': t[3]}
    return header


def register_request(conn):
    """
    Processing a register request from a client.
    :param conn: client connection
    """

    data = conn.recv(415)
    t = struct.unpack('255s160s', data)
    payload = {'name': t[0].decode('ascii').rstrip('\x00'), 'public_key': t[1]}

    if not client_service.find_by_name(payload['name']):
        new_client = Client(payload['name'], payload['public_key'])
        client_service.insert(new_client)
        logging.info(f'User \'{new_client.username}\' added to the database.')
        register_response(conn, new_client)
    else:
        error_response(conn, f'Could not create client. Username \'{payload["name"]}\' already exists.')


def client_list_request(conn, header):
    """
    Processing a client list request from a client.
    :param conn: client connection
    :param header: request header
    """

    clients_data = [(c.cid, bytes(c.username, 'utf-8')) for c in client_service.find_all() if
                    c.cid != header['client_id']]

    # Creating the client list using list comprehension
    response = {'number_of_clients': len(clients_data),
                'payload': [field for client in clients_data for field in client]}
    response['payload_size'] = response['number_of_clients'] * (CLIENT_ID_LENGTH + USERNAME_LENGTH)
    client_list_response(conn, response)


def public_key_request(conn):
    """
    Processing a public key request from a client.
    :param conn: client connection
    """

    data = conn.recv(16)
    t = struct.unpack('16s', data)
    client = client_service.find_by_id(t[0])

    if client:
        public_key = client.public_key
        public_key_response(conn, client.cid, public_key)
    else:
        error_response(conn, f'Public key request failed. Could not find client ID ({UUID(bytes=t[0])}).')


def message_request(conn, header):
    """
    Processing a message request from a client.
    :param conn: client connection
    :param header: request header
    """

    data = conn.recv(21)
    t = struct.unpack('16sIB', data)
    payload = {'client_id': t[0], 'content_size': t[1], 'message_type': t[2]}
    data = conn.recv(payload['content_size'])
    t = struct.unpack(f'{payload["content_size"]}s', data)

    payload['message_content'] = t[0]
    src_client = client_service.find_by_id(header['client_id'])
    target_client = client_service.find_by_id(payload['client_id'])

    if src_client and target_client:
        m = Message(target_client, src_client, payload['message_type'], payload['message_content'])
        message_service.insert(m)
        logging.info(f'Message from \'{src_client.username}\' to \'{target_client.username}\' added to the database.')

        # Getting the message ID, which is generated by sqlite.
        for msg in message_service.find_by_dst_client(target_client):
            if msg.from_client.cid == src_client.cid and msg.content == m.content:
                m.mid = msg.mid

        message_response(conn, target_client.cid, m.mid)
    else:
        fail = 'target'
        if not src_client:
            fail = 'source'
        error_response(conn, f'Failed to send message. Could not find {fail} client.')


def pull_request(conn, header):
    """
    Processing a pull request from a client.
    :param conn: client connection
    :param header: request header
    """

    client = client_service.find_by_id(header['client_id'])
    messages = message_service.find_by_dst_client(client)

    payload_size = 0
    payload = []
    for m in messages:
        content_size = len(m.content)
        s = struct.Struct(f'<16sIBI{content_size}s')
        s = s.pack(m.from_client.cid, m.mid, m.message_type, content_size, m.content)
        payload.append(s)
        payload_size += content_size

    pull_response(conn, payload, payload_size)

    # Deleting sent messages from db
    for m in messages:
        message_service.delete_by_id(m.mid)
        logging.info(f'Message {m.mid} pulled by \'{client.username}\' and deleted from the database.')
